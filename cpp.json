{
    "doubling.cpp": {
        "prefix": "@doubling",
        "body": [
            "template <class T>",
            "struct Doubling",
            "{",
            "  const int LOG;",
            "  vector< vector< int > > table;",
            "  ",
            "  Doubling(int sz, int64_t lim_t) : LOG(64 - __builtin_clzll(lim_t))",
            "  {",
            "    table.assign(LOG, vector< int >(sz, -1));",
            "  }",
            "",
            "  void set_next(int k, int x)",
            "  {",
            "    table[0][k] = x;",
            "  }",
            "",
            "  void build()",
            "  {",
            "    for(int k = 0; k + 1 < LOG; k++) {",
            "      for(int i = 0; i < table[k].size(); i++) {",
            "        if(table[k][i] == -1) table[k + 1][i] = -1;",
            "        else table[k + 1][i] = table[k][table[k][i]];",
            "      }",
            "    }",
            "  }",
            "",
            "  int query(int k, int64_t t)",
            "  {",
            "    for(int i = LOG - 1; i >= 0; i--) {",
            "      if((t >> i) & 1) k = table[i][k];",
            "    }",
            "    return k;",
            "  }",
            "};"
        ],
        "description": "@doubling"
    },
    "lazySegmentTree.cpp": {
        "prefix": "@lazySegmentTree",
        "body": [
            "#pragma region LazySegmentTree",
            "// https://ei1333.github.io/algorithm/segment-tree.html",
            "template< typename Monoid, typename OperatorMonoid = Monoid >",
            "struct LazySegmentTree {",
            "    using F = function< Monoid(Monoid, Monoid) >;",
            "    using G = function< Monoid(Monoid, OperatorMonoid) >;",
            "    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;",
            "    using P = function< OperatorMonoid(OperatorMonoid, int) >;",
            "    int sz;",
            "    vector< Monoid > data;",
            "    vector< OperatorMonoid > lazy;",
            "    const F f;",
            "    const G g;",
            "    const H h;",
            "    const P p;",
            "    const Monoid M1;",
            "    const OperatorMonoid OM0;",
            "    LazySegmentTree(int n, const F op, const G mapping, const H composition, const P p,",
            "                    const Monoid &M, const OperatorMonoid ID)",
            "        : f(op), g(mapping), h(composition), p(p), M1(M), OM0(ID)",
            "        {",
            "            sz = 1;",
            "            while(sz < n) sz <<= 1;",
            "            data.assign(2 * sz, M1);",
            "            lazy.assign(2 * sz, OM0);",
            "        }",
            "",
            "    void set(int k, const Monoid &x) {",
            "        data[k + sz] = x;",
            "    }",
            "    void build(){",
            "        for(int k = sz - 1; k > 0; k--) {",
            "            data[k] = f(data[2 * k + 0], data[2 * k + 1]);",
            "        }",
            "    }",
            "    void propagate(int k, int len) {",
            "        if(lazy[k] != OM0) {",
            "            if(k < sz) {",
            "                lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);",
            "                lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);",
            "            }",
            "            data[k] = g(data[k], p(lazy[k], len));",
            "            lazy[k] = OM0;",
            "        }",
            "    }",
            "    Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {",
            "        propagate(k, r - l);",
            "        if(r <= a || b <= l) {",
            "            return data[k];",
            "        }else if(a <= l && r <= b) {",
            "            lazy[k] = h(lazy[k], x);",
            "            propagate(k, r - l);",
            "            return data[k];",
            "        }else{",
            "            return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),",
            "                                update(a, b, x, 2 * k + 1, (l + r) >> 1, r));",
            "        }",
            "    }",
            "    Monoid update(int a, int b, const OperatorMonoid &x) {",
            "        return update(a, b, x, 1, 0, sz);",
            "    }",
            "    Monoid query(int a, int b, int k, int l, int r){",
            "        propagate(k, r - l);",
            "        if(r <= a || b <= l) {",
            "            return M1;",
            "        }else if(a <= l && r <= b) {",
            "            return data[k];",
            "        }else{",
            "            return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),",
            "                    query(a, b, 2 * k + 1, (l + r) >> 1, r));",
            "        }",
            "    }",
            "    Monoid query(int a, int b) {",
            "        return query(a, b, 1, 0, sz);",
            "    }",
            "    Monoid operator[](const int &k) {",
            "        return query(k, k + 1);",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@lazySegmentTree"
    },
    "primeFactorize.cpp": {
        "prefix": "@primeFactorize",
        "body": [
            "// 素因数分解",
            "// O(√N)",
            "// 複数回行うならosa_k法も検討",
            "vec<P> primeFactorize(ll N) {",
            "    vec<P> res;",
            "    for (ll a = 2; a * a <= N; ++a) {",
            "        if (N % a != 0) continue;",
            "        ll ex = 0; // 指数",
            "        // 割れる限り割り続ける",
            "        while (N % a == 0) {",
            "            ++ex;",
            "            N /= a;",
            "        }",
            "        res.push_back({a, ex});",
            "    }",
            "    // 最後に残った数について",
            "    if (N != 1) res.push_back({N, 1});",
            "    return res;",
            "}"
        ],
        "description": "@primeFactorize"
    },
    "UnionFind.cpp": {
        "prefix": "@UnionFind",
        "body": [
            "#pragma region UnionFind",
            "// https://qiita.com/DaikiSuyama/items/444e409423bd1b4b83d7",
            "class UnionFind{",
            "public:",
            "    vector<ll> parent; //parent[i]はiの親",
            "    vector<ll> siz; //素集合のサイズを表す配列(1で初期化)",
            "    umap<ll,vector<ll>> group; //集合ごとに管理する(key:集合の代表元、value:集合の要素の配列)",
            "    ll n; //要素数",
            "    UnionFind(ll n_):n(n_),parent(n_),siz(n_,1){ ",
            "        //全ての要素の根が自身であるとして初期化",
            "        for(ll i=0;i<n;i++){parent[i]=i;}",
            "    }",
            "    //!@brief データxの属する木の根を取得(経路圧縮も行う)",
            "    ll root(ll x){",
            "        if(parent[x]==x) return x;",
            "        return parent[x]=root(parent[x]);//代入式の値は代入した変数の値なので、経路圧縮できる",
            "    }",
            "    //!@brief xとyの木を併合",
            "    void unite(ll x,ll y){",
            "        ll rx=root(x);//xの根",
            "        ll ry=root(y);//yの根",
            "        if(rx==ry) return;//同じ木にある時",
            "        //小さい集合を大きい集合へと併合(ry→rxへ併合)",
            "        if(siz[rx]<siz[ry]) swap(rx,ry);",
            "        siz[rx]+=siz[ry];",
            "        parent[ry]=rx;//xとyが同じ木にない時はyの根ryをxの根rxにつける",
            "    }",
            "    //!@brief xとyが属する木が同じかを判定",
            "    bool same(ll x,ll y){",
            "        ll rx=root(x);",
            "        ll ry=root(y);",
            "        return rx==ry;",
            "    }",
            "    //!@brief xの素集合のサイズを取得",
            "    ll size(ll x){",
            "        return siz[root(x)];",
            "    }",
            "    //!@brief 素集合をそれぞれグループ化",
            "    void grouping(){",
            "        //経路圧縮を先に行う",
            "        REP(i,n)root(i);",
            "        //mapで管理する(デフォルト構築を利用)",
            "        REP(i,n)group[parent[i]].push_back(i);",
            "    }",
            "    //!@brief 素集合系を削除して初期化",
            "    void clear(){",
            "        REP(i,n){parent[i]=i;}",
            "        siz=vector<ll>(n,1);",
            "        group.clear();",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@UnionFind"
    },
    "REPR.cpp": {
        "prefix": "REPR",
        "body": [
            "REPR(${1:i}, ${2:N}){",
            "    ${3:/*code*/}",
            "}"
        ],
        "description": "REPR"
    },
    "REP.cpp": {
        "prefix": "REP",
        "body": [
            "REP(${1:i}, ${2:N}){",
            "    ${3:/*code*/}",
            "}"
        ],
        "description": "REP"
    },
    "FOR.cpp": {
        "prefix": "FOR",
        "body": [
            "FOR(${1:i}, ${2:N+1}, ${3:1}){",
            "    ${4:/*code*/}",
            "}"
        ],
        "description": "FOR"
    },
    "EACH.cpp": {
        "prefix": "EACH",
        "body": [
            "EACH(${1:v}, ${2:mp}){",
            "    ${3:/*code*/}",
            "}"
        ],
        "description": "EACH"
    },
    "IO.cpp": {
        "prefix": "@IO",
        "body": [
            "#pragma region IOMacros",
            "template<class T>",
            "istream &operator>>(istream &stream, vec<T>& o){REP(i, o.size())stream >> o[i];return stream;}",
            "template<class T>",
            "ostream &operator<<(ostream &stream, vec<T>& objs){REP(i, objs.size())stream << objs[i] << \" \";stream << el;return stream;}",
            "",
            "#define I(T, ...) ;T __VA_ARGS__;__i(__VA_ARGS__);",
            "void __i() {}",
            "template<class T, class... Ts> void __i(T&& o, Ts&&... args){cin >> o;__i(forward<Ts>(args)...);}",
            "",
            "void O() {cout << el;}",
            "template<class T, class... Ts> void O(T&& o, Ts&&... args){cerr << o << \" \";O(forward<Ts>(args)...);}",
            "#pragma endregion"
        ],
        "description": "@IO"
    },
    "cout.cpp": {
        "prefix": "cout",
        "body": [
            "cout << $1 << el;"
        ],
        "description": "cout"
    },
    "REP2.cpp": {
        "prefix": "REP2",
        "body": [
            "REP(${1:i}, ${2:N}){",
            "    REP(${3:j}, ${4:M}){",
            "        ${5:/*code*/}",
            "    }",
            "}"
        ],
        "description": "REP2"
    },
    "digitNum.cpp": {
        "prefix": "digitNum",
        "body": [
            "(ll)to_string(abs($1)).length()"
        ],
        "description": "digitNum"
    },
    "warshall_floyd.cpp": {
        "prefix": "@warshall_floyd",
        "body": [
            "#pragma region warshall_floyd",
            "// O(|V|^3)",
            "vector<vector<ll>> warshall_floyd(const vector<vector<ll>> &_dist){",
            "    int V = _dist.size();",
            "    vector<vector<ll>> dist(_dist);",
            "    REP(k, V) {",
            "        REP(i, V) {",
            "            REP(j, V) {",
            "                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
            "            }",
            "        }",
            "    }",
            "    return dist;",
            "}",
            "vector<vector<ll>> warshall_floyd(const graph& g) {",
            "    int V = g.V;",
            "    vector<vector<ll>> dist(V, vector<ll>(V, INF));",
            "    REP(i, V){",
            "        dist[i][i] = 0;",
            "        for(auto e : g.G[i]){",
            "            dist[i][e.to] = e.cost;",
            "        }",
            "    }",
            "    return warshall_floyd(dist);",
            "}",
            "#pragma endregion"
        ],
        "description": "@warshall_floyd"
    },
    "fact.cpp": {
        "prefix": "@fact",
        "body": [
            "#pragma region fact",
            "template <class T>",
            "T fact(T x){",
            "    T ret=1;",
            "    ll i_len=(ll)x;",
            "    for(T i=2; (ll)i<=i_len; i+=1){",
            "        ret*=i;",
            "    }",
            "    return ret;",
            "}",
            "#pragma endregion"
        ],
        "description": "@fact"
    },
    "FOR2.cpp": {
        "prefix": "FOR2",
        "body": [
            "FOR(${1:i}, ${2:N+1}, ${3:1}){",
            "    FOR(${4:j}, ${5:M+1}, ${6:1}){",
            "        ${7:/*code*/}",
            "    }",
            "}"
        ],
        "description": "FOR2"
    },
    "prim.cpp": {
        "prefix": "@prim",
        "body": [
            "pair<ll, graph> prim(const graph& g){",
            "    graph r(g.V);",
            "    priority_queue<edge, vector<edge>, greater<edge>> que;",
            "    que.push({-1, 0, 0});",
            "    ll sum = 0;",
            "    while(!que.empty()){",
            "        auto [f, t, c] = que.top(); que.pop();",
            "        if(r.G[t].size() > 0) continue;",
            "        if(f != -1) r.add_edge(f, t, c);",
            "        sum += c;",
            "        for(auto& e: g.G[t]){",
            "            if(r.G[e.to].size() > 0) continue;",
            "            que.push(e);",
            "        }",
            "    }",
            "    return {sum, r};",
            "}"
        ],
        "description": "@prim"
    },
    "sameCount.cpp": {
        "prefix": "@sameCount",
        "body": [
            "// 重複した要素をカウント",
            "// O(N)",
            "template <class Iterator>",
            "umap<typename iterator_traits<Iterator>::value_type, ll>",
            "sameCount(const Iterator begin, const Iterator end){",
            "    umap<typename iterator_traits<Iterator>::value_type, ll> mp;",
            "    for (auto it = begin; it != end; ++it) ++mp[*it];",
            "    return mp;",
            "}"
        ],
        "description": "@sameCount"
    },
    "segtree.cpp": {
        "prefix": "@segtree",
        "body": [
            "#pragma region segtree",
            "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
            "  public:",
            "    segtree() : segtree(0) {}",
            "    segtree(int n) : segtree(std::vector<S>(n, e())) {}",
            "    segtree(const std::vector<S>& v) : _n(int(v.size())) {",
            "        constexpr auto ceil_pow2 = [](int n){",
            "            int x = 0;",
            "            while ((1U << x) < (unsigned int)(n)) x++;",
            "            return x;",
            "        };",
            "        log = ceil_pow2(_n);",
            "        size = 1 << log;",
            "        d = std::vector<S>(2 * size, e());",
            "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
            "        for (int i = size - 1; i >= 1; i--) {",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    S get(int p) {",
            "        assert(0 <= p && p < _n);",
            "        return d[p + size];",
            "    }",
            "",
            "    S prod(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        S sml = e(), smr = e();",
            "        l += size;",
            "        r += size;",
            "",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(sml, smr);",
            "    }",
            "",
            "    S all_prod() { return d[1]; }",
            "",
            "    template <bool (*f)(S)> int max_right(int l) {",
            "        return max_right(l, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int max_right(int l, F f) {",
            "        assert(0 <= l && l <= _n);",
            "        assert(f(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!f(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    l = (2 * l);",
            "                    if (f(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    template <bool (*f)(S)> int min_left(int r) {",
            "        return min_left(r, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int min_left(int r, F f) {",
            "        assert(0 <= r && r <= _n);",
            "        assert(f(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!f(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    r = (2 * r + 1);",
            "                    if (f(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "",
            "  private:",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "",
            "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "};",
            "",
            "ll op(ll a, ll b){",
            "    return min(a, b);",
            "}",
            "ll e(){",
            "    return INF;",
            "}",
            "",
            "using stree = segtree<ll, op, e>;",
            "#pragma endregion",
            ""
        ],
        "description": "@segtree"
    },
    "travelingSalesman.cpp": {
        "prefix": "@travelingSalesman",
        "body": [
            "struct travelingSalesman{",
            "    int V;",
            "    vector<vector<ll>> dist, dp;",
            "    travelingSalesman(graph& _g): V(_g.V), dist(_g.V, vector<ll>(_g.V, INF)), dp(1<<_g.V, vector<ll>(_g.V, -1)){",
            "        REP(i, V){",
            "            EACH(e, _g.G[i]){",
            "                dist[e.from][e.to] = e.cost;",
            "            }",
            "        }",
            "    }",
            "    ll calc(){return calc(0, 0);}",
            "    ll calc(int s, int v){",
            "        if(dp[s][v] >= 0){",
            "            return dp[s][v];",
            "        }",
            "",
            "        if(s == (1<<V)-1 && v == 0){",
            "            return dp[s][v] = 0;",
            "        }",
            "",
            "        ll ans = INF;",
            "        REP(u, V){",
            "            if(!(s >> u & 1)){",
            "                ans = min(ans, calc(s | 1 << u, u) + dist[v][u]);",
            "            }",
            "        }",
            "",
            "        dp[s][v] = ans;",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "@travelingSalesman"
    },
    "isprime.cpp": {
        "prefix": "@isprime",
        "body": [
            "// Nが素数であるか",
            "// O(√N)",
            "bool isprime(ll N) {",
            "    if (N == 1) return false;",
            "    for (ll i = 2; i * i <= N; ++i) {",
            "        if (N % i == 0) return false;",
            "    }",
            "    return true;",
            "}",
            ""
        ],
        "description": "@isprime"
    },
    "popcount.cpp": {
        "prefix": "popcount",
        "body": [
            "__builtin_popcount($1)"
        ],
        "description": "popcount"
    },
    "graph.cpp": {
        "prefix": "@graph",
        "body": [
            "#pragma region graph",
            "struct edge{",
            "    ll from, to, cost;",
            "    bool operator<(const edge& r) const{return cost<r.cost;}",
            "    bool operator>(const edge& r) const{return cost>r.cost;}",
            "};",
            "struct graph{",
            "    ll V;",
            "    vector<vector<edge> > G;",
            "    graph(ll n){",
            "        init(n);",
            "    }",
            "    void init(ll n){",
            "        V = n;",
            "        G.resize(V);",
            "    }",
            "    // 無向グラフ",
            "    void add_edge(ll s, ll t, ll cost = 1){",
            "        add_diedge(s, t, cost);",
            "        add_diedge(t, s, cost);",
            "    }",
            "    // 有向グラフ",
            "    void add_diedge(ll s, ll t, ll cost = 1){",
            "        edge e;",
            "        e.from = s, e.to = t, e.cost = cost;",
            "        G[s].push_back(e);",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@graph"
    },
    "sort.cpp": {
        "prefix": "sort",
        "body": [
            "sort(ALL($1));"
        ],
        "description": "sort"
    },
    "osa_k.cpp": {
        "prefix": "@osa_k",
        "body": [
            "#pragma region osa_k",
            "// 素因数分解に前処理をかける",
            "// 前処理 O(NloglogN)",
            "// クエリ O(logN)",
            "struct osa_k{",
            "    vec<ll> min_factor;",
            "    osa_k(int N): min_factor(N+1){",
            "        //2以上の数を一度素数候補に入れる",
            "        for(int i = 0; i <= N; i++) min_factor[i] = i;",
            "        //それぞれの数について最小の素因数を求める",
            "        for(int i = 2; i*i <= N; i++){",
            "            if(min_factor[i] == i){",
            "                for(int j = 2; i*j <= N; j++){",
            "                    if(min_factor[i*j] > i){",
            "                        min_factor[i*j] = i;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "    vec<P> factorize(int N){",
            "        vec<P> res;",
            "        vec<P>::iterator it;",
            "        int b = -1;",
            "        while(N > 1){",
            "            if(b != min_factor[N]){",
            "                res.push_back({min_factor[N], 0});",
            "                b = min_factor[N];",
            "                it = res.end()-1;",
            "            }",
            "            it->se++;",
            "            N /= min_factor[N];",
            "        }",
            "        return move(res);",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@osa_k"
    },
    "kruskal.cpp": {
        "prefix": "@kruskal",
        "body": [
            "#pragma region kruskal",
            "pair<ll, graph> kruskal(ll V, vector<edge>& edges, ll K = 0){",
            "    UnionFind uf(V);",
            "    graph r(V);",
            "    sort(edges.begin(), edges.end());",
            "    ll sum = 0;",
            "    EACH(e, edges){",
            "        if(K <= 0) break;",
            "        auto [f, t, c] = e;",
            "        if(uf.same(f, t)) continue;",
            "        r.add_edge(f, t, c);",
            "        uf.unite(f, t);",
            "        sum += c;",
            "        K--;",
            "    }",
            "    return {sum, r};",
            "}",
            "",
            "pair<ll, graph> kruskal(const graph& g, ll K = 0){",
            "    vector<edge> edges;",
            "    K = g.V - K; // 張る辺の最大値",
            "    REP(i, g.V){",
            "        EACH(e, g.G[i]){",
            "            if(e.to <= i) continue;",
            "            edges.push_back(e);",
            "        }",
            "    }",
            "    return kruskal(g.V, edges, K);",
            "}",
            "#pragma endregion"
        ],
        "description": "@kruskal"
    },
    "enumDivisors.cpp": {
        "prefix": "@enumDivisors",
        "body": [
            "// 約数列挙",
            "//O(√N)",
            "vector<ll> enumDivisors(ll N) {",
            "    vector<ll> res1, res2;",
            "    for (ll i = 1; i * i <= N; ++i) {",
            "        if (N % i == 0) {",
            "            res1.push_back(i);",
            "            if (N/i != i) res2.push_back(N/i);",
            "        }",
            "    }",
            "    res1.reserve(res1.size()+res2.size());",
            "    copy(res2.rbegin(), res2.rend(), back_inserter(res1));",
            "    return res1;",
            "}"
        ],
        "description": "@enumDivisors"
    },
    "binarySearch.cpp": {
        "prefix": "@binarySearch",
        "body": [
            "// x∈[l, r] | f(x) = true となる最大のxを返す",
            "template <class Func>",
            "ll BinarySearch(ll l, ll r, Func f){",
            "    while(l < r){",
            "        const ll m = (l+r+1)/2;",
            "        if(f(m)) l = m;",
            "        else     r = m-1;",
            "    }",
            "    return l;",
            "}"
        ],
        "description": "@binarySearch"
    },
    "bfs.cpp": {
        "prefix": "@bfs",
        "body": [
            "// O(V+E)",
            "umap<ll, ll> bfs(const graph& g, ll s, ll limit = INF){",
            "    vector<ll> d(g.V, INF);",
            "    umap<ll, ll> ret;",
            "    d[s] = 0;",
            "    queue<P> que;",
            "    que.push({0, s});",
            "    ret[s] = 0;",
            "    while(!que.empty()){",
            "        auto [c, v] = que.front(); que.pop();",
            "        if(d[v]<c) continue;",
            "        for(auto e : g.G[v]){",
            "            if(d[e.to]>d[v]+1 && limit>=d[v]+1){",
            "                d[e.to] = d[v]+1;",
            "                que.push({d[e.to],e.to});",
            "                ret[e.to] = d[e.to];",
            "            }",
            "        }",
            "    }",
            "    return ret;",
            "}"
        ],
        "description": "@bfs"
    },
    "cpp_int.cpp": {
        "prefix": "@cpp_int",
        "body": [
            "",
            "#include <boost/multiprecision/cpp_int.hpp>",
            "using namespace boost::multiprecision;"
        ],
        "description": "@cpp_int"
    },
    "pow.cpp": {
        "prefix": "@pow",
        "body": [
            "ll dpow(ll x, ll n, int mod = __INT_MAX__) {",
            "    long long ret = 1;",
            "    while (n > 0) {",
            "        if (n & 1) ret = ret * x % mod;",
            "        x = x * x % mod;",
            "        n >>= 1;",
            "    }",
            "    return ret;",
            "}",
            ""
        ],
        "description": "@pow"
    },
    "combn.cpp": {
        "prefix": "@combn",
        "body": [
            "#pragma region combn",
            "// nCrを求める",
            "// 前処理 O(n)",
            "// クエリ O(1)",
            "template <class MINT>",
            "struct combination {",
            "    vector<MINT> fact, ifact;",
            "    combination(int n):fact(n+1),ifact(n+1) {",
            "        fact[0] = 1;",
            "        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
            "        ifact[n] = fact[n].inv();",
            "        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
            "    }",
            "    MINT operator()(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        return fact[n]*ifact[k]*ifact[n-k];",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@combn"
    },
    "modint.cpp": {
        "prefix": "@modint",
        "body": [
            "#pragma region modint",
            "template<ll m> struct modint{",
            "protected:",
            "    ll v=0;",
            "public:",
            "    //コンストラクタ",
            "    modint(ll x=0){while(x<0)x+=m;v=x%m;}",
            "    modint(const modint &r){v=r.val();}",
            "    //算術演算子(単項)",
            "    modint operator -(){return modint(-v);} ",
            "    modint& operator ++(){if(++v>=m)v-=m; return *this;}",
            "    modint operator ++(int){modint t = *this; ++*this; return t;}",
            "    modint& operator --(){if(--v<0)v+=m; return *this;}",
            "    modint operator --(int){modint t = *this; --*this; return t;}",
            "    //算術演算子(二項)",
            "    friend modint operator +(const modint &l, const modint &r){return modint(l)+=r;}",
            "    friend modint operator -(const modint &l, const modint &r){return modint(l)-=r;}",
            "    friend modint operator *(const modint &l, const modint &r){return modint(l)*=r;}",
            "    friend modint operator /(const modint &l, const modint &r){return modint(l)/=r;}",
            "    // キャスト演算子",
            "    explicit operator int() const {return val();}",
            "    explicit operator ll() const {return val();}",
            "    //代入演算子",
            "    modint &operator +=(const modint &r){",
            "        v+=r.val();",
            "        if(v>=m)v-=m;",
            "        return *this;",
            "    }",
            "    modint &operator -=(const modint &r){",
            "        if(v<r.val())v+=m;",
            "        v-=r.val();",
            "        return *this;",
            "    }",
            "    modint &operator *=(const modint &r){",
            "        v=v*r.val()%m;",
            "        return *this;",
            "    }",
            "    modint &operator /=(const modint &r){",
            "        v=v*r.inv().val()%m;",
            "        return *this;",
            "    }",
            "    //等価比較演算子",
            "    friend bool operator ==(const modint &l, const modint& r){return l.val()==r.val();}",
            "    friend bool operator <(const modint &l, const modint& r){return l.val()<r.val();}",
            "    friend bool operator >(const modint &l, const modint& r){return l.val()>r.val();}",
            "    friend bool operator !=(const modint &l, const modint& r){return l.val()!=r.val();}",
            "    // 各種関数",
            "    int val() const{return v;}",
            "    constexpr static ll mod(){return m;}",
            "    static modint raw(ll x){modint r;r.v=x;return r;}",
            "    modint inv() const{",
            "        ll a=v,b=m,u=1,v=0;",
            "        while(b){",
            "            ll t=a/b;",
            "            a-=t*b;swap(a,b);",
            "            u-=t*v;swap(u,v);",
            "        }",
            "        u %= m; ",
            "        if (u < 0) u += m;",
            "        return u;",
            "    }",
            "    modint pow(ll n) const{",
            "        modint ret = 1, x(v);",
            "        while (n > 0) {",
            "            if (n & 1) ret *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "    //入出力ストリーム",
            "    friend istream &operator>>(istream &is,modint& x){ll t;is>>t;x=t;return (is);}",
            "    friend ostream &operator<<(ostream &os,const modint& x){return os<<x.val();}",
            "    ",
            "};",
            "using modint1000000007 = modint<1000000007>;",
            "using modint998244353 = modint<998244353>;",
            "#pragma endregion"
        ],
        "description": "@modint"
    },
    "contains.cpp": {
        "prefix": "contains",
        "body": [
            "${1:mp}.find($2) != $1.end()"
        ],
        "description": "contains"
    },
    "dijkstra.cpp": {
        "prefix": "@dijkstra",
        "body": [
            "// O(|E|log|V|)",
            "vector<ll> dijkstra(const graph& g, ll s){",
            "    vector<ll> d(g.V, INF);",
            "    d[s] = 0;",
            "    priority_queue<P,vector<P>, greater<P>> que;",
            "    que.push({0, s});",
            "    while(!que.empty()){",
            "        auto [c, v] = que.top(); que.pop();",
            "        if(d[v]<c) continue;",
            "        for(auto e : g.G[v]){",
            "            if(d[e.to]>d[v]+e.cost){",
            "                d[e.to] = d[v]+e.cost;",
            "                que.push({d[e.to],e.to});",
            "            }",
            "        }",
            "    }",
            "    return d;",
            "}"
        ],
        "description": "@dijkstra"
    },
    "combk.cpp": {
        "prefix": "@combk",
        "body": [
            "#pragma region combk",
            "// nCrを求める",
            "// 前処理 O(k)",
            "// クエリ O(k)",
            "template <class MINT>",
            "struct combination {",
            "    vector<MINT> fact, ifact;",
            "    combination(int k):fact(k+1),ifact(k+1) {",
            "        fact[0] = 1;",
            "        for (int i = 1; i <= k; ++i) fact[i] = fact[i-1]*i;",
            "        ifact[k] = fact[k].inv();",
            "        for (int i = k; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
            "    }",
            "    MINT operator()(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        MINT ans(1);",
            "        for(int i = n; i >= n - k + 1; --i) ans *= i;",
            "        return ans * ifact[k];",
            "    }",
            "};",
            "#pragma endregion"
        ],
        "description": "@combk"
    },
    "cumsum.cpp": {
        "prefix": "@cumsum",
        "body": [
            "//Aの累積和をとる．[l, r)の和はR[r] - R[l]で取ることができる．",
            "template<class T>",
            "vec<T> cumsum(const vec<T> &A) {",
            "    vec<T> R(A.size()+1);",
            "    REP(i, A.size()) R[i + 1] = R[i] + A[i];",
            "    return R;",
            "}"
        ],
        "description": "@cumsum"
    },
    "main.cpp": {
        "prefix": "@main",
        "body": [
            "#pragma region Macros",
            "#include <bits/stdc++.h>",
            "#if defined(LOCAL) || defined(ONLINE_JUDGE) || defined(_DEBUG)",
            "#include <atcoder/all>",
            "#endif",
            "using namespace std;",
            "#define REP(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)",
            "#define REPR(i, n) for(int i=(n); i>=0; --i)",
            "#define FOR(i, n, m) for(int i=(m), i##_len=(n); i<i##_len; ++i)",
            "#define EACH(i, v) for(const auto& i : v)",
            "#define ALL(x) (x).begin(),(x).end()",
            "#define ALLR(x) (x).rbegin(),(x).rend()",
            "template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }",
            "template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }",
            "template<class T>using vec = vector<T>;",
            "template<class T, class U>using umap = unordered_map<T, U>;",
            "using ll = long long;",
            "using P = pair<ll, ll>;",
            "using vl = vec<ll>;",
            "#define fi first",
            "#define se second",
            "#define el endl",
            "constexpr ll INF = numeric_limits<ll>::max()/2-1;",
            "#pragma endregion",
            "",
            "void Main();",
            "",
            "int main(){",
            "    std::cin.tie(nullptr);",
            "    std::cout << std::fixed << std::setprecision(15);",
            "    Main();",
            "    return 0;",
            "}",
            "",
            "void Main(){",
            "    $1",
            "}",
            ""
        ],
        "description": "@main"
    },
    "unique.cpp": {
        "prefix": "unique",
        "body": [
            "$1.erase(unique($1.begin(), $1.end()), $1.end());"
        ],
        "description": "unique"
    }
}